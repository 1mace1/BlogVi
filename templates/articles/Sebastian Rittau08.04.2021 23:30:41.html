<h1>Contributing to typeshed</h1>
<p>Welcome!  typeshed is a community project that aims to work for a wide
range of Python users and Python codebases.  If you're trying a type
checker on your Python code, your experience and what you can contribute
are important to the project's success.</p>
<h2>The contribution process at a glance</h2>
<ol>
<li>Read the <a href="README.md">README.md file</a>.</li>
<li>Set up your environment to be able to <a href="README.md#running-the-tests">run all tests</a>.  They should pass.</li>
<li><a href="#preparing-changes">Prepare your changes</a>:<ul>
<li>Small fixes and additions can be submitted directly as pull requests,
  but <a href="#discussion">contact us</a> before starting significant work.</li>
<li>Create your stubs <a href="#stub-file-coding-style">conforming to the coding style</a>.</li>
<li>Make sure your tests pass cleanly on <code>mypy</code>, <code>pytype</code>, and <code>flake8</code>.</li>
<li>Reformat your stubs with <code>black</code> and <code>isort</code>.</li>
</ul>
</li>
<li><a href="#submitting-changes">Submit your changes</a> by opening a pull request.</li>
<li>You can expect a reply within a few days:<ul>
<li>Diffs are merged when considered ready by the core team.</li>
<li>Feel free to ping the core team if your pull request goes without
  a reply for more than a few days.</li>
</ul>
</li>
</ol>
<p>For more details, read below.</p>
<h2>Discussion</h2>
<p>If you've run into behavior in the type checker that suggests the type
stubs for a given library are incorrect or incomplete,
we want to hear from you!</p>
<p>Our main forum for discussion is the project's <a href="https://github.com/python/typeshed/issues">GitHub issue
tracker</a>.  This is the right
place to start a discussion of any of the above or most any other
topic concerning the project.</p>
<p>For less formal discussion, try the typing chat room on
<a href="https://gitter.im/python/typing">gitter.im</a>.  Some Mypy core developers
are almost always present; feel free to find us there and we're happy
to chat.  Substantive technical discussion will be directed to the
issue tracker.</p>
<h3>Code of Conduct</h3>
<p>Everyone participating in the typeshed community, and in particular in
our issue tracker, pull requests, and IRC channel, is expected to treat
other people with respect and more generally to follow the guidelines
articulated in the <a href="https://www.python.org/psf/codeofconduct/">Python Community Code of
Conduct</a>.</p>
<h2>Submitting Changes</h2>
<p>Even more excellent than a good bug report is a fix for a bug, or the
implementation of a much-needed stub. We'd love to have
your contributions.</p>
<p>We use the usual GitHub pull-request flow, which may be familiar to
you if you've contributed to other projects on GitHub.  For the
mechanics, see <a href="https://github.com/python/mypy/wiki/Using-Git-And-GitHub">Mypy's git and GitHub workflow help page</a>,
or <a href="https://help.github.com/articles/using-pull-requests/">GitHub's own documentation</a>.</p>
<p>Anyone interested in type stubs may review your code.  One of the
maintainers will merge your pull request when they think it's ready.
For every pull request, we aim to promptly either merge it or say why
it's not yet ready; if you go a few days without a reply, please feel
free to ping the thread by adding a new comment.</p>
<p>To get your pull request merged sooner, you should explain why you are
making the change. For example, you can point to a code sample that is
processed incorrectly by a type checker. It is also helpful to add
links to online documentation or to the implementation of the code
you are changing.</p>
<p>Also, do not squash your commits after you have submitted a pull request, as this
erases context during review. We will squash commits when the pull request is merged.</p>
<p>At present the maintainers are (alphabetically):
* David Fisher (@ddfisher)
* ≈Åukasz Langa (@ambv)
* Jukka Lehtosalo (@JukkaL)
* Ivan Levkivskyi (@ilevkivskyi)
* Matthias Kramm (@matthiaskramm)
* Greg Price (@gnprice)
* Sebastian Rittau (@srittau)
* Guido van Rossum (@gvanrossum)
* Shantanu (@hauntsaninja)
* Rune Tynan (@CraftSpider)
* Aku Viljanen (@Akuli)
* Jelle Zijlstra (@JelleZijlstra)</p>
<p>NOTE: the process for preparing and submitting changes also applies to
maintainers.  This ensures high quality contributions and keeps
everybody on the same page.  Avoid direct pushes to the repository.</p>
<h2>Preparing Changes</h2>
<h3>Before you begin</h3>
<p>If your change will be a significant amount of work to write, we highly
recommend starting by opening an issue laying out what you want to do.
That lets a conversation happen early in case other contributors disagree
with what you'd like to do or have ideas that will help you do it.</p>
<h3>What to include</h3>
<p>Stubs should include the complete interface (classes, functions,
constants, etc.) of the module they cover, but it is not always
clear exactly what is part of the interface.</p>
<p>The following should always be included:
- All objects listed in the module's documentation.
- All objects included in <code>__all__</code> (if present).</p>
<p>Other objects may be included if they are being used in practice
or if they are not prefixed with an underscore. This means
that typeshed will generally accept contributions that add missing
objects, even if they are undocumented. Undocumented objects should
be marked with a comment of the form <code># undocumented</code>.
Example:</p>
<p><code>python
def list2cmdline(seq: Sequence[str]) -&gt; str: ...  # undocumented</code></p>
<p>We accept such undocumented objects because omitting objects can confuse
users. Users who see an error like "module X has no attribute Y" will
not know whether the error appeared because their code had a bug or
because the stub is wrong. Although it may also be helpful for a type
checker to point out usage of private objects, we usually prefer false
negatives (no errors for wrong code) over false positives (type errors
for correct code). In addition, even for private objects a type checker
can be helpful in pointing out that an incorrect type was used.</p>
<h3>Incomplete stubs</h3>
<p>We accept partial stubs, especially for larger packages. These need to
follow the following guidelines:</p>
<ul>
<li>Included functions and methods must list all arguments, but the arguments
  can be left unannotated. Do not use <code>Any</code> to mark unannotated arguments
  or return values.</li>
<li>Partial classes must include a <code>__getattr__()</code> method marked with an
  <code># incomplete</code> comment (see example below).</li>
<li>Partial modules (i.e. modules that are missing some or all classes,
  functions, or attributes) must include a top-level <code>__getattr__()</code>
  function marked with an <code># incomplete</code> comment (see example below).</li>
<li>Partial packages (i.e. packages that are missing one or more sub-modules)
  must have a <code>__init__.pyi</code> stub that is marked as incomplete (see above).
  A better alternative is to create empty stubs for all sub-modules and
  mark them as incomplete individually.</li>
</ul>
<p>Example of a partial module with a partial class <code>Foo</code> and a partially
annotated function <code>bar()</code>:</p>
<p>```python
def <strong>getattr</strong>(name: str) -&gt; Any: ...  # incomplete</p>
<p>class Foo:
    def <strong>getattr</strong>(self, name: str) -&gt; Any: ...  # incomplete
    x: int
    y: str</p>
<p>def bar(x: str, y, *, z=...): ...
```</p>
<h3>Using stubgen</h3>
<p>Mypy includes a tool called <a href="https://mypy.readthedocs.io/en/latest/stubgen.html">stubgen</a>
that auto-generates stubs for Python and C modules using static analysis,
Sphinx docs, and runtime introspection.  It can be used to get a starting
point for your stubs.  Note that this generator is currently unable to
determine most argument and return types and omits them or uses <code>Any</code> in
their place.  Fill out manually the types that you know.</p>
<h3>Stub file coding style</h3>
<h4>Syntax example</h4>
<p>The below is an excerpt from the types for the <code>datetime</code> module.</p>
<p>```python
MAXYEAR: int
MINYEAR: int</p>
<p>class date:
    def <strong>init</strong>(self, year: int, month: int, day: int) -&gt; None: ...
    @classmethod
    def fromtimestamp(cls, timestamp: float) -&gt; date: ...
    @classmethod
    def today(cls) -&gt; date: ...
    @classmethod
    def fromordinal(cls, ordinal: int) -&gt; date: ...
    @property
    def year(self) -&gt; int: ...
    def replace(self, year: int = ..., month: int = ..., day: int = ...) -&gt; date: ...
    def ctime(self) -&gt; str: ...
    def weekday(self) -&gt; int: ...
```</p>
<h4>Conventions</h4>
<p>Stub files are <em>like</em> Python files and you should generally expect them
to look the same.  Your tools should be able to successfully treat them
as regular Python files.  However, there are a few important differences
you should know about.</p>
<p>Style conventions for stub files are different from PEP 8. The general
rule is that they should be as concise as possible.  Specifically:
* all function bodies should be empty;
* prefer <code>...</code> over <code>pass</code>;
* prefer <code>...</code> on the same line as the class/function signature;
* avoid vertical whitespace between consecutive module-level functions,
  names, or methods and fields within a single class;
* use a single blank line between top-level class definitions, or none
  if the classes are very small;
* do not use docstrings;
* use variable annotations instead of type comments, even for stubs
  that target older versions of Python.</p>
<p>Stubs should be reformatted with the formatters
<a href="https://github.com/psf/black">black</a> and
<a href="https://github.com/PyCQA/isort">isort</a> before submission.
These formatters are included in typeshed's <code>requirements-tests-py3.txt</code> file.
A sample <code>pre-commit</code> file is included in the typeshed repository.  Copy it
to <code>.git/hooks</code> and adjust the path to your virtual environment's <code>bin</code>
directory to automatically reformat stubs before commit.</p>
<p>Stub files should only contain information necessary for the type
checker, and leave out unnecessary detail:
* for arguments with a default, use <code>...</code> instead of the actual
  default;
* for arguments that default to <code>None</code>, use <code>Optional[]</code> explicitly
  (see below for details);
* use <code>float</code> instead of <code>Union[int, float]</code>.</p>
<p>Some further tips for good type hints:
* use built-in generics (<code>list</code>, <code>dict</code>, <code>tuple</code>, <code>set</code>), instead
  of importing them from <code>typing</code>, <strong>except</strong> for arbitrary length tuples
  (<code>Tuple[int, ...]</code>) (see
  <a href="https://github.com/python/mypy/issues/9980">python/mypy#9980</a>);
* in Python 3 stubs, import collections (<code>Mapping</code>, <code>Iterable</code>, etc.)
  from <code>collections.abc</code> instead of <code>typing</code>;
* avoid invariant collection types (<code>list</code>, <code>dict</code>) in argument
  positions, in favor of covariant types like <code>Mapping</code> or <code>Sequence</code>;
* avoid Union return types: https://github.com/python/mypy/issues/1693;
* in Python 2, whenever possible, use <code>unicode</code> if that's the only
  possible type, and <code>Text</code> if it can be either <code>unicode</code> or <code>bytes</code>;
* use platform checks like <code>if sys.platform == 'win32'</code> to denote
  platform-dependent APIs.</p>
<p>Imports in stubs are considered private (not part of the exported API)
unless:
* they use the form <code>from library import name as name</code> (sic, using
  explicit <code>as</code> even if the name stays the same); or
* they use the form <code>from library import *</code> which means all names
  from that library are exported.</p>
<p>When adding type hints, avoid using the <code>Any</code> type when possible. Reserve
the use of <code>Any</code> for when:
* the correct type cannot be expressed in the current type system; and
* to avoid Union returns (see above).</p>
<p>Note that <code>Any</code> is not the correct type to use if you want to indicate
that some function can accept literally anything: in those cases use
<code>object</code> instead.</p>
<p>Stub files support forward references natively.  In other words, the
order of class declarations and type aliases does not matter in
a stub file.  You can also use the name of the class within its own
body.  Focus on making your stubs clear to the reader.  Avoid using
string literals in type annotations.</p>
<p>Type variables and aliases you introduce purely for legibility reasons
should be prefixed with an underscore to make it obvious to the reader
they are not part of the stubbed API.</p>
<p>When adding type annotations for context manager classes, annotate
the return type of <code>__exit__</code> as bool only if the context manager
sometimes suppresses exceptions -- if it sometimes returns <code>True</code>
at runtime. If the context manager never suppresses exceptions,
have the return type be either <code>None</code> or <code>Optional[bool]</code>. If you
are not sure whether exceptions are suppressed or not or if the
context manager is meant to be subclassed, pick <code>Optional[bool]</code>.
See https://github.com/python/mypy/issues/7214 for more details.</p>
<p>A few guidelines for protocol names below. In cases that don't fall
into any of those categories, use your best judgement.</p>
<ul>
<li>Use plain names for protocols that represent a clear concept
  (e.g. <code>Iterator</code>, <code>Container</code>).</li>
<li>Use <code>SupportsX</code> for protocols that provide callable methods (e.g.
  <code>SupportsInt</code>, <code>SupportsRead</code>, <code>SupportsReadSeek</code>).</li>
<li>Use <code>HasX</code> for protocols that have readable and/or writable attributes
  or getter/setter methods (e.g. <code>HasItems</code>, <code>HasFileno</code>).</li>
</ul>
<p>NOTE: there are stubs in this repository that don't conform to the
style described above.  Fixing them is a great starting point for new
contributors.</p>
<h3>Stub versioning</h3>
<p>There are separate directories for <code>stdlib</code> (standard library) and <code>stubs</code>
(all other stubs). For standard library stubs Python version support is
given in <code>VERSIONS</code> file. Each line in this file is a module or package name
followed by <code>:</code>, followed by the oldest <em>supported</em> Python version where
the module is available.</p>
<p>Third-party stubs only support Python 3 by default. You can optionally supply
Python 2 stubs for a package by placing them into a <code>@python2</code> subdirectory
for the corresponding distribution. Some older stubs also indicate Python 2
support by setting <code>python2 = True</code> in the corresponding <code>METADATA.toml</code> file.</p>
<p>You can use checks
like <code>if sys.version_info &gt;= (3, 8):</code> to denote new functionality introduced
in a given Python version or solve type differences.  When doing so, only use
one-tuples or two-tuples.  This is because:</p>
<ul>
<li>
<p>mypy doesn't support more fine-grained version checks; and more
  importantly</p>
</li>
<li>
<p>the micro versions of a Python release will change over time in your
  checking environment and the checker should return consistent results
  regardless of the micro version used.</p>
</li>
</ul>
<p>Because of this, if a given functionality was introduced in, say, Python
3.7.4, your check:</p>
<ul>
<li>should be expressed as <code>if sys.version_info &gt;= (3, 7):</code></li>
<li>should NOT be expressed as <code>if sys.version_info &gt;= (3, 7, 4):</code></li>
<li>should NOT be expressed as <code>if sys.version_info &gt;= (3, 8):</code></li>
</ul>
<p>This makes the type checker assume the functionality was also available
in 3.7.0 - 3.7.3, which while <em>technically</em> incorrect is relatively
harmless.  This is a strictly better compromise than using the latter
two forms, which would generate false positive errors for correct use
under Python 3.7.4.</p>
<p>Note: in its current implementation, typeshed cannot contain stubs for
multiple versions of the same third-party library.  Prefer to generate
stubs for the latest version released on PyPI at the time of your
stubbing. The oldest version of the library for which the stubs are still
applicable (i.e. reflect the actual runtime behaviour) can be indicated
in <code>METADATA.toml</code> as <code>version = "x.y"</code>. Note that only two most significant
version levels are supported (i.e. only single dot). When a significant change
is made in the library, the version of the stub should be bumped (note that
previous versions are still available on PyPI).</p>
<p>Internal typeshed machinery will periodically build and upload modified
third party packages to PyPI, each time this happens the least significant
version level is incremented. For example, if <code>stubs/foo/METADATA.toml</code> has
<code>version = "x.y"</code> the package on PyPI will be updated from <code>types-foo-x.y.n</code>
to <code>types-foo-x.y.n+1</code>.</p>
<h3>What to do when a project's documentation and implementation disagree</h3>
<p>Type stubs are meant to be external type annotations for a given
library.  While they are useful documentation in its own merit, they
augment the project's concrete implementation, not the project's
documentation.  Whenever you find them disagreeing, model the type
information after the actual implementation and file an issue on the
project's tracker to fix their documentation.</p>
<h2>Issue-tracker conventions</h2>
<p>We aim to reply to all new issues promptly.  We'll assign one or more
labels to indicate we've triaged an issue, but most typeshed issues
are relatively simple (stubs for a given module or package are
missing, incomplete or incorrect) and we won't add noise to the
tracker by labeling all of them.  Please see the
<a href="https://github.com/python/typeshed/issues/labels">list of all labels</a>
for a detailed description of the labels we use.</p>
<p>Sometimes a PR can't make progress until some external issue is
addressed.  We indicate this by editing the subject to add a <code>[WIP]</code>
prefix.  (This should be removed before committing the issue once
unblocked!)</p>
<h3>Maintainer guidelines</h3>
<p>Maintainers should follow these rules when processing pull requests:</p>
<ul>
<li>Always wait for tests to pass before merging PRs.</li>
<li>Use "<a href="https://github.com/blog/2141-squash-your-commits">Squash and merge</a>" to merge PRs.</li>
<li>Delete branches for merged PRs (by maintainers pushing to the main repo).</li>
<li>Make sure commit messages to master are meaningful. For example, remove irrelevant
  intermediate commit messages.</li>
<li>If stubs for a new library are submitted, notify the library's maintainers.</li>
</ul>
<p>When reviewing PRs, follow these guidelines:</p>
<ul>
<li>Typing is hard. Try to be helpful and explain issues with the PR,
  especially to new contributors.</li>
<li>When reviewing auto-generated stubs, just scan for red flags and obvious
  errors. Leave possible manual improvements for separate PRs.</li>
<li>When reviewing large, hand-crafted PRs, you only need to look for red flags
  and general issues, and do a few spot checks.</li>
<li>Review smaller, hand-crafted PRs thoroughly.</li>
</ul>